import {PluginConfig, PluginOptions} from '@sdr/core';
import {buildSchema} from 'graphql';
import {TypeNode} from 'graphql/language/ast';

let validateField = function<TSource, TContext, TArgs>(
  fieldName: string,
  type: TypeNode,
  options: {optional: boolean; noFieldCount: boolean; arrayFieldIndex: number}
) {
  let validation = '';

  switch (type.kind) {
    case 'NamedType':
      if (options.optional) {
        validation += `
    if(model.${fieldName}!==null && model.${fieldName} !==undefined){
    `;
      }
      if (!options.noFieldCount) {
        validation += 'fieldCount++;';
      }
      switch (type.name.value) {
        case 'String':
          validation += `if((typeof model.${fieldName}) !== 'string'){return false;}`;
          break;
        case 'Boolean':
          validation += `if((typeof model.${fieldName}) !== 'boolean'){return false;}`;
          break;
        case 'Int':
          validation += `if((typeof model.${fieldName}) !== 'number'){return false;}`;
          break;
        case 'Float':
          validation += `if((typeof model.${fieldName}) !== 'number'){return false;}`;
          break;
        default:
          validation += `if(validate${type.name.value}(model.${fieldName})){return false;}`;
      }
      if (options.optional) {
        validation += `}`;
      }

      break;
    case 'ListType':
      if (options.optional) {
        validation += `
    if(model.${fieldName}!==null && model.${fieldName} !==undefined){ 
    `;
      }

      if (!options.noFieldCount) {
        validation += 'fieldCount++;';
      }

      validation += `if(!Array.isArray(model.${fieldName})){return false;}`;
      validation += `for(let ind${options.arrayFieldIndex}=0;ind${
        options.arrayFieldIndex
      }<model.${fieldName}.length;ind${options.arrayFieldIndex}++){
        ${validateField(`${fieldName}[ind${options.arrayFieldIndex}]`, type.type, {
          ...options,
          noFieldCount: true,
          arrayFieldIndex: options.arrayFieldIndex + 1,
        })}
      }`;
      if (options.optional) {
        validation += `}`;
      }

      break;
    case 'NonNullType':
      validation += `if(model.${fieldName}===null || model.${fieldName}===undefined){return false;}`;
      validation += validateField(fieldName, type.type, {...options, optional: false});
      break;
  }
  return validation;
};

export function plugin(options: PluginOptions, config: {}) {
  const schema = buildSchema(options.schemaString);

  let typeMap = schema.getTypeMap();
  for (const key in typeMap) {
    if (!typeMap[key].astNode?.directives.some(a => a.name.value === 'model')) {
      delete typeMap[key];
    }
  }

  let validation = `/* This file was generated by https://github.com/schema-driven-rest/plugin-validate-models */
  /* tslint:disable */
`;
  for (const key in typeMap) {
    const type = typeMap[key];
    if (!type.astNode.directives.some(a => a.name.value === 'model')) {
      continue;
    }

    validation += `export function validate${type.name}(model: any){`;

    if (type.astNode.kind === 'ObjectTypeDefinition' || type.astNode.kind === 'InterfaceTypeDefinition' || type.astNode.kind === 'InputObjectTypeDefinition') {
      validation += `if(model===null || model ===undefined) return false;`;
      validation += `let fieldCount=0;`;
      for (const field of type.astNode.fields) {
        validation += validateField(field.name.value, field.type, {
          optional: true,
          noFieldCount: false,
          arrayFieldIndex: 1,
        });
      }
      if ((type.astNode as any).interfaces) {
        for (const _interface of (type.astNode as any).interfaces) {
          validation += `if(validate${_interface.name.value}(model)) return true;`;
        }
      }
      validation += 'if(Object.keys(model).length !== fieldCount) return false;';
      validation += 'return true;';
    }
    if (type.astNode.kind === 'EnumTypeDefinition') {
      const values = eval('type.astNode.values');
      for (const value of values) {
        validation += `if(model==='${value.name.value}') return true;`;
      }
      validation += 'return false;';
    }
    if (type.astNode.kind === 'UnionTypeDefinition') {
      for (const t of type.astNode.types) {
        validation += `if(validate${t.name.value}(model)) return true;`;
      }
      validation += 'return false;';
    }

    validation += '}';
  }
  return validation;
}

export const config: PluginConfig = {
  dependsOn: ['@sdr/controller'],
};
